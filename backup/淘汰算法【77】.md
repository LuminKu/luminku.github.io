在计算机系统中，淘汰算法（也称替换算法）主要用于内存管理、缓存系统等场景，当资源（如内存页、缓存空间）不足时，决定哪些数据应被移除以腾出空间。根据应用场景不同，主要分为‌**页面置换算法**‌（常用于操作系统虚拟内存）和‌**缓存淘汰算法**‌（常用于Redis、CPU缓存等）。

以下是几种最常用和经典的淘汰算法：

### 主要淘汰算法

1. ‌**先进先出（FIFO, First-In-First-Out）**‌
   - ‌**原理**‌：选择最早进入内存或缓存的页面/数据进行淘汰，如同队列结构。
   - ‌**优点**‌：实现简单，开销小。
   - ‌**缺点**‌：可能淘汰掉频繁使用的页面（如“Belady异常”：增加物理块数反而缺页率上升），性能不稳定。
2. ‌**最久未使用（LRU, Least Recently Used）,最近最少使用**‌
   - ‌**原理**‌：淘汰最近最久未被访问的页面/数据，基于“局部性原理”——近期被访问的，未来也可能被访问。
   - ‌**优点**‌：能较好地适应程序访问模式，缺页率通常低于FIFO，是实际系统中广泛使用的算法（如Redis的`allkeys-lru`策略）。
   - ‌**缺点**‌：实现需要维护访问时间顺序（如用双向链表+哈希表），硬件或软件开销较大。
3. ‌**最不常用（LFU, Least Frequently Used）**‌
   - ‌**原理**‌：淘汰访问频率最低的页面/数据，关注历史访问次数而非时间。
   - ‌**优点**‌：能有效保留长期热点数据，适合访问模式稳定的场景（如Redis的`allkeys-lfu`策略）。
   - ‌**缺点**‌：新加入的数据因初始频率为0易被误淘汰；历史高频但近期冷门的数据可能被错误淘汰。现代实现（如Redis）使用衰减计数器（`lfu-log-factor`、`lfu-decay-time`）来缓解此问题。
4. ‌**时钟算法（Clock / Second Chance）**‌
   - ‌**原理**‌：FIFO的改进版，使用环形链表和访问位（reference bit）。当页面被访问时，访问位置1；淘汰时，扫描环形链表，遇到访问位为0的页面即淘汰；若为1，则置0并继续扫描，给予一次“第二次机会”。
   - ‌**优点**‌：兼顾了FIFO的简单性和LRU的部分效果，实现成本适中，是许多操作系统（如Unix/Linux）的默认页面置换算法。
   - ‌**缺点**‌：仍可能淘汰频繁访问但恰好未被访问的页面。
5. ‌**最优算法（OPT, Optimal Page Replacement）**‌
   - ‌**原理**‌：淘汰未来最长时间内不会被访问的页面。理论上能获得最低缺页率。
   - ‌**优点**‌：作为理想基准，用于评估其他算法的性能。
   - ‌**缺点**‌：‌**无法实现**‌，因为需要预知未来访问序列，仅用于理论分析。
6. ‌**随机算法（RAND, Random Replacement）**‌
   - ‌**原理**‌：随机选择一个页面进行淘汰。
   - ‌**优点**‌：实现极其简单，开销极低。
   - ‌**缺点**‌：命中率不稳定，可能淘汰重要数据，但在某些场景（如TLB）为追求速度而使用。

### 其他相关算法

- ‌**MRU（Most Recently Used）**‌：淘汰最近刚被访问的数据，适用于某些特定访问模式（如循环访问）。
- ‌**ARC（Adaptive Replacement Cache）**‌：IBM开发的自适应算法，动态平衡LRU和LFU，性能优于单一算法，但实现复杂。
- ‌**Redis淘汰策略**‌：Redis提供了多种内存淘汰策略，包括`noeviction`、`allkeys-random`、`volatile-ttl`、`allkeys-lru`、`allkeys-lfu`等，其中`allkeys-lru`和`allkeys-lfu`是处理热点数据的主流方案‌。

### 总结

| 算法      | 核心思想             | 是否常用             | 实现复杂度 |
| --------- | -------------------- | -------------------- | ---------- |
| ‌**FIFO**‌  | 最早进入的先淘汰     | ✅ 是                 | 低         |
| ‌**LRU**‌   | 最久未访问的先淘汰   | ✅ 是（广泛使用）     | 中高       |
| ‌**LFU**‌   | 访问次数最少的先淘汰 | ✅ 是（尤其在缓存中） | 中         |
| ‌**Clock**‌ | 带“第二次机会”的FIFO | ✅ 是（操作系统常用） | 中         |
| ‌**OPT**‌   | 未来最久不访问的     | ❌ 理论仅用           | 无         |
| ‌**RAND**‌  | 随机淘汰             | ✅ 是（特定场景）     | 极低       |

在实际应用中，‌**LRU**‌ 和 ‌**LFU**‌ 是现代缓存系统（如Redis、CDN、浏览器缓存）的主流选择，而操作系统内核则多采用 ‌**Clock**‌ 算法。选择哪种算法需权衡性能、实现复杂度和应用场景‌。